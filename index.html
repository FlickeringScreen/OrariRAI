<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Calendario Turni RAI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: #0f3460;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            padding: 40px;
            max-width: 800px;
            margin: 0 auto;
            border: 1px solid #1a4d7a;
        }

        h1 {
            color: #4a9eba;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #c8d3dc;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #c8d3dc;
            font-weight: 600;
            font-size: 14px;
        }

        input[type="text"],
        input[type="file"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #1a4d7a;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
            background: #16213e;
            color: #f8f9fa;
        }

        input[type="text"]:focus,
        input[type="file"]:focus {
            outline: none;
            border-color: #4a9eba;
        }

        input[type="file"] {
            cursor: pointer;
            color: #c8d3dc;
        }

        input[type="file"]::file-selector-button {
            background: #1a4d7a;
            color: #f8f9fa;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }

        input[type="file"]::file-selector-button:hover {
            background: #4a9eba;
        }

        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #4a9eba 0%, #3a7d92 100%);
            color: #0f3460;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-bottom: 10px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(74, 158, 186, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #495057;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        button.secondary:hover {
            box-shadow: 0 10px 20px rgba(40, 167, 69, 0.4);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        @media (max-width: 600px) {
            .button-group {
                grid-template-columns: 1fr;
            }
        }

        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .status.success {
            background: #1e4620;
            color: #5cb85c;
            border: 1px solid #4cae4c;
            display: block;
        }

        .status.error {
            background: #4a1c1c;
            color: #f8d7da;
            border: 1px solid #c23a52;
            display: block;
        }

        .status.info {
            background: #1a3a52;
            color: #5bc0de;
            border: 1px solid #46b8da;
            display: block;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #16213e;
            border-top: 4px solid #4a9eba;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .shifts-preview {
            margin-top: 20px;
            padding: 20px;
            background: #16213e;
            border-radius: 8px;
            border: 2px solid #4a9eba;
            display: none;
        }

        .shifts-preview.active {
            display: block;
        }

        .shifts-preview h3 {
            color: #4a9eba;
            margin-bottom: 15px;
        }

        .shift-item {
            padding: 10px;
            margin: 8px 0;
            background: #0f3460;
            border-radius: 5px;
            border-left: 4px solid #4a9eba;
            color: #f8f9fa;
        }

        .shift-item strong {
            color: #4a9eba;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            margin-top: 8px;
            margin-right: 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-badge.mfs,
        .status-badge.mns,
        .status-badge.fs {
            background: #4a1c1c;
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
        }

        .status-badge.riposo {
            background: #1e4620;
            color: #5cb85c;
            border: 1px solid #4cae4c;
        }

        .footer {
            margin-top: 40px;
            text-align: center;
            color: #6c757d;
            font-size: 11px;
            padding: 20px 0 10px 0;
            border-top: 1px solid #1a4d7a;
        }

        .footer p {
            margin: 5px 0;
        }

        h3 {
            color: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìÖ Generatore Calendario Turni RAI</h1>
        <p class="subtitle">Genera il tuo calendario turni in formato ICS</p>

        <div id="uploadSection">
            <div class="form-group">
                <label for="pdfFile">Carica il PDF dell'orario:</label>
                <input type="file" id="pdfFile" accept="application/pdf,.pdf" required>
            </div>

            <div class="form-group">
                <label for="firstName">Nome:</label>
                <input type="text" id="firstName" placeholder="Mario" required>
            </div>

            <div class="form-group">
                <label for="lastName">Cognome:</label>
                <input type="text" id="lastName" placeholder="Rossi" required>
            </div>

            <button type="button" id="extractBtn">Estrai Turni dal PDF</button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p style="margin-top: 10px; color: #666;">Elaborazione in corso...</p>
        </div>

        <div class="status" id="status"></div>

        <div class="shifts-preview" id="shiftsPreview">
            <h3>‚úÖ Turni Trovati:</h3>
            <div id="shiftsList"></div>
            
            <div class="button-group">
                <button type="button" id="downloadBtn" class="secondary">‚¨áÔ∏è Scarica File ICS</button>
            </div>
        </div>

        <div class="footer">
            <p>Creato da Antonio Amato</p>
            <p>Versione 0.8.4 Beta</p>
        </div>
    </div>

    <script>
        // Enhanced logging for Chrome DevTools
        console.log('=== RAI SHIFT CALENDAR APP STARTED ===');
        console.log('Timestamp:', new Date().toISOString());
        console.log('User Agent:', navigator.userAgent);
        console.log('Platform:', navigator.platform);
        console.log('Screen:', window.screen.width + 'x' + window.screen.height);
        console.log('Viewport:', window.innerWidth + 'x' + window.innerHeight);
        
        // Check if PDF.js is loaded
        if (typeof pdfjsLib === 'undefined') {
            console.error('‚úó‚úó‚úó PDF.js library NOT LOADED ‚úó‚úó‚úó');
        } else {
            console.log('‚úì PDF.js library loaded, version:', pdfjsLib.version);
        }
        
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        console.log('‚úì PDF.js worker configured');

        let extractedSchedule = null;
        let currentFirstName = '';
        let currentLastName = '';
        
        // Test localStorage availability
        try {
            localStorage.setItem('test', 'test');
            localStorage.removeItem('test');
            console.log('‚úì LocalStorage is available');
        } catch (e) {
            console.error('‚úó LocalStorage is NOT available:', e);
        }
        
        // Global error handlers
        window.addEventListener('error', function(e) {
            console.error('‚úó‚úó‚úó UNCAUGHT ERROR ‚úó‚úó‚úó');
            console.error('Message:', e.message);
            console.error('File:', e.filename);
            console.error('Line:', e.lineno, 'Col:', e.colno);
            console.error('Error object:', e.error);
        });
        
        window.addEventListener('unhandledrejection', function(e) {
            console.error('‚úó‚úó‚úó UNHANDLED PROMISE REJECTION ‚úó‚úó‚úó');
            console.error('Reason:', e.reason);
            console.error('Promise:', e.promise);
        });

        const SHIFT_TIMES = {
            '4o': ['05:55', '13:30'], '5o': ['05:55', '14:30'], '01': ['05:45', '14:20'],
            '05': ['05:55', '14:30'], '14': ['12:15', '20:50'], '57': ['11:25', '19:00'],
            '5T': ['13:00', '20:35'], '1M': ['09:30', '18:05'], '2E': ['11:25', '20:00'],
            '2Q': ['14:00', '22:35'], '3Z': ['07:30', '16:05'], '6E': ['05:30', '13:05'],
            '6L': ['12:00', '19:35'], '7N': ['15:25', '23:00'], 'B1': ['05:50', '14:25'],
            'C': ['07:00', '15:35'], 'C*': ['07:00', '14:35'], 'Ce*': ['07:00', '14:35'],
            'D': ['08:00', '16:35'], 'D*': ['08:00', '15:35'], 'De*': ['08:00', '15:35'],
            'E': ['08:30', '17:05'], 'E*': ['08:30', '16:05'], 'EZ': ['10:25', '19:00'],
            'F': ['09:00', '17:35'], 'F*': ['09:00', '16:35'], 'Fe*': ['09:00', '16:35'],
            'F0': ['08:25', '17:00'], 'FH': ['08:25', '16:00'], 'G': ['10:00', '18:35'],
            'G*': ['10:00', '17:35'], 'G+': ['11:00', '18:35'], 'H': ['11:00', '19:30'],
            'I': ['12:45', '21:20'], 'I*': ['12:45', '20:20'], 'L': ['13:30', '22:05'],
            'L*': ['13:30', '21:05'], 'L+': ['14:30', '22:05'], 'M': ['15:00', '23:35'],
            'M*': ['15:00', '22:35'], 'M+': ['16:00', '23:35'], 'N': ['15:55', '00:30'],
            'N+': ['16:55', '00:30'], 'N1': ['16:25', '01:00'], 'O': ['16:55', '01:30'],
            'RC': ['05:30', '14:05'], 'RG': ['12:00', '20:35'], 'RU': ['05:00', '13:35'],
            'SR': ['10:45', '19:20'], 'TC': ['06:30', '15:05'], 'TD': ['06:30', '14:05'],
            'UD': ['10:25', '18:00'], 'US': ['11:30', '19:05'], 'VI': ['11:30', '20:05'],
            '90': ['00:00', '00:00'], '91': ['00:00', '00:00'], '92': ['00:00', '00:00'],
            '93': ['00:00', '00:00'], '94': ['00:00', '00:00'], '95': ['00:00', '00:00'],
            '96': ['00:00', '00:00'], '97': ['00:00', '00:00'], '99': ['00:00', '00:00']
        };

        const LOCATIONS = {
            'N1': 'Nomentano 1', 'N2': 'Nomentano 2', 'N3': 'Nomentano 3',
            'N4': 'Nomentano 4', 'N5': 'Nomentano 5', 'N6': 'Nomentano 6',
            'AFP1': 'Foro Italico Sala Prove 1', 'AFI': 'Foro Italico',
            '1': 'Teulada Studio 1', '2': 'Teulada Studio 2', '3': 'Teulada Studio 3',
            '4': 'Teulada Studio 4', '5': 'Teulada Studio 5', '6': 'Teulada Studio 6',
            '7': 'Teulada Studio 7', '8': 'Teulada Studio 8', '9': 'Teulada Studio 9',
            '10': 'Teulada Studio 10', '11': 'Teulada Studio 11', '12': 'Teulada Studio 12',
            'SR1': 'Saxa Rubra 1', 'SR2': 'Saxa Rubra 2', 'SR3': 'Saxa Rubra 3',
            'SR4': 'Saxa Rubra 4', 'SR5': 'Saxa Rubra 5 - Rai Sport',
            'RAN': 'Saxa Rubra - RAI NEWS',
            'S9A': 'Studio 9A', 'S09': 'Studio 09', 'S12': 'Studio 12',
            'S04': 'Studio 04', 'S07': 'Studio 07', 'S03': 'Studio 03',
            'TG1': 'TG1', 'TG2': 'TG2', 'TG3': 'TG3',
            'SE': 'Servizio Esterno',
            'ES01': 'Esterna 1', 'ES02': 'Esterna 2', 'ES03': 'Esterna 3', 'ES04': 'Esterna 4',
            'ES05': 'Esterna 5', 'ES06': 'Esterna 6', 'ES07': 'Esterna 7', 'ES08': 'Esterna 8',
            'ES09': 'Esterna 9', 'ES10': 'Esterna 10',
            'SPL1': 'Esterna Sopralluogo 1', 'SPL2': 'Esterna Sopralluogo 2',
            'AUM': 'Aula Montecitorio', 'MC': 'Studiolo Montecitorio',
            'QUA': 'Quirinale', 'QUB': 'Quirinale Stand Up', 'SEN': 'Senato',
            'DISP': 'Disposizione', 'Disp.': 'Disposizione',
            'TdV': 'Teatro delle Vittorie',
            'ITA645': 'ITA645', '645': 'ITA645',
            'ITA475': 'ITA475', '475': 'ITA475',
            'SW': 'Smart Working'
        };

        function log(message, data = null) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            if (data !== null) {
                console.log(`[${timestamp}] ${message}`, data);
            } else {
                console.log(`[${timestamp}] ${message}`);
            }
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('active', show);
        }

        async function extractTextFromPDF(file) {
            log('üìÑ Starting PDF extraction...', {
                fileName: file.name,
                fileSize: file.size,
                fileType: file.type
            });
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                log('‚úì File converted to ArrayBuffer', { bufferSize: arrayBuffer.byteLength });
                
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                log('‚úì PDF document loaded', { numPages: pdf.numPages });
                
                let fullText = '';

                for (let i = 1; i <= pdf.numPages; i++) {
                    log(`Processing page ${i}/${pdf.numPages}...`);
                    
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    
                    log(`Page ${i} has ${textContent.items.length} text items`);
                    
                    const items = textContent.items.sort((a, b) => {
                        const yDiff = Math.abs(a.transform[5] - b.transform[5]);
                        if (yDiff > 5) {
                            return b.transform[5] - a.transform[5];
                        }
                        return a.transform[4] - b.transform[4];
                    });
                    
                    let lastY = null;
                    let lineText = '';
                    
                    items.forEach(item => {
                        const y = item.transform[5];
                        
                        if (lastY !== null && Math.abs(y - lastY) > 5) {
                            fullText += lineText + '\n';
                            lineText = '';
                        }
                        
                        lineText += item.str + ' ';
                        lastY = y;
                    });
                    
                    fullText += lineText + '\n';
                }

                log('‚úì PDF text extraction complete', { 
                    totalLength: fullText.length,
                    preview: fullText.substring(0, 200) + '...'
                });
                
                return fullText;
            } catch (error) {
                console.error('‚úó PDF extraction failed:', error);
                throw error;
            }
        }

        function findEmployeeLine(text, firstName, lastName) {
            const lines = text.split('\n');
            
            // Normalize names for matching
            const normalizedLastName = lastName.toUpperCase().replace(/\s+/g, '');
            const normalizedFirstName = firstName.toUpperCase().replace(/\s+/g, '');
            
            // Create search patterns - handle spaces in names
            const searchPatterns = [
                // Exact match with comma and space
                `${lastName.toUpperCase()}, ${firstName.toUpperCase()}`,
                `${lastName.toUpperCase()},${firstName.toUpperCase()}`,
                // Without spaces in last name
                `${normalizedLastName}, ${normalizedFirstName}`,
                `${normalizedLastName},${normalizedFirstName}`,
                // Just last name
                lastName.toUpperCase(),
                normalizedLastName
            ];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Try exact patterns first (with spaces preserved)
                for (let j = 0; j < 4; j++) {
                    if (line.includes(searchPatterns[j])) {
                        log(`‚úì Found employee at line ${i}: ${line.substring(0, 100)}`);
                        return { index: i, line: line, lines: lines };
                    }
                }
                
                // Try normalized (no spaces) version
                const normalizedLine = line.replace(/\s+/g, '');
                for (let j = 4; j < searchPatterns.length; j++) {
                    const normalizedPattern = searchPatterns[j].replace(/\s+/g, '');
                    if (normalizedLine.includes(normalizedPattern)) {
                        log(`‚úì Found employee at line ${i}: ${line.substring(0, 100)}`);
                        return { index: i, line: line, lines: lines };
                    }
                }
            }
            return null;
        }

        function extractWeekDates(text) {
            const lines = text.split('\n');
            
            // Look for pattern: DD/MM/YYYY DD/MM/YYYY (with or without spaces around it)
            // This appears near "PERIODO DI RIFERIMENTO"
            for (const line of lines) {
                // Try to find two dates in DD/MM/YYYY format
                const match = line.match(/(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2})\/(\d{2})\/(\d{4})/);
                if (match) {
                    const startDay = parseInt(match[1]);
                    const startMonth = parseInt(match[2]);
                    const year = parseInt(match[3]);
                    
                    log(`‚úì Found week dates: ${match[0]}`);
                    return generateWeekDates(startDay, startMonth, year);
                }
            }
            
            // Alternative: Look for dates near "PERIODO DI RIFERIMENTO"
            const periodoIndex = text.indexOf('PERIODO DI RIFERIMENTO');
            if (periodoIndex !== -1) {
                // Extract text around this marker (500 chars before and after)
                const chunk = text.substring(Math.max(0, periodoIndex - 500), periodoIndex + 200);
                const match = chunk.match(/(\d{2})\/(\d{2})\/(\d{4})\s*-?\s*(\d{2})\/(\d{2})\/(\d{4})/);
                if (match) {
                    const startDay = parseInt(match[1]);
                    const startMonth = parseInt(match[2]);
                    const year = parseInt(match[3]);
                    
                    log(`‚úì Found week dates near PERIODO: ${match[0]}`);
                    return generateWeekDates(startDay, startMonth, year);
                }
            }
            
            log('‚ùå WARNING: Could not find week dates in PDF! Using current date.');
            // Use current date as fallback
            const today = new Date();
            const monday = new Date(today);
            const day = monday.getDay();
            const diff = monday.getDate() - day + (day === 0 ? -6 : 1); // Adjust to Monday
            monday.setDate(diff);
            
            return generateWeekDates(monday.getDate(), monday.getMonth() + 1, monday.getFullYear());
        }

        function generateWeekDates(day, month, year) {
            const dates = [];
            const startDate = new Date(year, month - 1, day);

            for (let i = 0; i < 7; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                dates.push(date);
            }

            return dates;
        }

        function parseSchedule(text, firstName, lastName) {
            const employeeData = findEmployeeLine(text, firstName, lastName);
            
            if (!employeeData) {
                return { found: false, schedule: [] };
            }

            const weekDates = extractWeekDates(text);
            const schedule = [];
            
            const nameLine = employeeData.lines[employeeData.index];
            log(`Name line: ${nameLine}`);
            
            // Match pattern: LASTNAME (uppercase, may have spaces), FIRSTNAME (mixed case)
            // Handle names with spaces like "PEDIO CICALA, Andrea"
            const dataPartMatch = nameLine.match(/[A-Z\s]+,\s*[A-Za-z]+\s+(.*)/);
            if (!dataPartMatch) {
                log('‚ùå Could not extract data part from name line');
                return { found: true, schedule: [] };
            }
            
            let dataPart = dataPartMatch[1];
            
            // CRITICAL: Remove all > characters as they mess up parsing
            dataPart = dataPart.replace(/>/g, ' ');
            log(`Data part (after removing >): ${dataPart}`);
            
            const shiftsFound = [];
            let match;
            
            // 1. Find quoted shifts (e.g., 'G ', '2Q')
            const quotedPattern = /'([A-Z*+0-9\s]{1,4})'/g;
            
            while ((match = quotedPattern.exec(dataPart)) !== null) {
                const shiftCode = match[1].trim();
                if (SHIFT_TIMES[shiftCode]) {
                    shiftsFound.push({
                        code: shiftCode,
                        position: match.index,
                        endPosition: match.index + match[0].length
                    });
                    log(`  Found quoted shift code: '${shiftCode}'`);
                }
            }
            
            // 2. Find ALL unquoted work shifts (L, M, VI, F, etc.) AND riposo/XXX codes
            // Tokenize by any whitespace
            const tokens = dataPart.split(/\s+/).filter(t => t.length > 0);
            let currentPos = 0;
            
            for (let i = 0; i < tokens.length; i++) {
                const token = tokens[i];
                
                // Find this token's position in the original string
                const tokenPos = dataPart.indexOf(token, currentPos);
                currentPos = tokenPos + token.length;
                
                // Check if already covered by quoted shift
                const isOverlapping = shiftsFound.some(s => 
                    tokenPos >= s.position && tokenPos < s.endPosition
                );
                
                if (!isOverlapping) {
                    // Check if it's a valid shift code
                    if (SHIFT_TIMES[token]) {
                        shiftsFound.push({
                            code: token,
                            position: tokenPos,
                            endPosition: tokenPos + token.length
                        });
                        log(`  Found unquoted shift code: ${token} at position ${tokenPos}`);
                    }
                    // Check if it's a riposo code
                    else if (['90', '91', '92', '93', '94', '95', '96', '97', '99', 'RCF'].includes(token)) {
                        shiftsFound.push({
                            code: token,
                            position: tokenPos,
                            endPosition: tokenPos + token.length
                        });
                        log(`  Found riposo code: ${token} at position ${tokenPos}`);
                    }
                    // Check if it's XXX
                    else if (token === 'XXX') {
                        shiftsFound.push({
                            code: 'XXX',
                            position: tokenPos,
                            endPosition: tokenPos + 3
                        });
                        log(`  Found XXX placeholder at position ${tokenPos}`);
                    }
                }
            }
            
            shiftsFound.sort((a, b) => a.position - b.position);
            
            log(`‚úì Found ${shiftsFound.length} shift codes/placeholders`);
            
            if (shiftsFound.length === 0) {
                log('‚ùå No shifts found on name line');
                return { found: true, schedule: [] };
            }
            
            if (shiftsFound.length !== 7) {
                log(`‚ö†Ô∏è Warning: Expected 7 days but found ${shiftsFound.length}`);
            }
            
            shiftsFound.forEach((shift, dayIndex) => {
                if (dayIndex >= 7) {
                    log(`‚ö†Ô∏è Skipping extra shift at day ${dayIndex + 1}`);
                    return;
                }
                
                let afterShift;
                if (dayIndex < shiftsFound.length - 1) {
                    afterShift = dataPart.substring(shift.endPosition, shiftsFound[dayIndex + 1].position);
                } else {
                    afterShift = dataPart.substring(shift.endPosition);
                }
                
                log(`  After shift '${shift.code}': "${afterShift.trim()}"`);
                
                const tokens = afterShift.trim().split(/\s+/).filter(t => t.length > 0);
                
                let location = 'SE';
                let hasMFS = false;
                let hasMNS = false;
                let hasFS = false;
                let locationTokens = [];
                let foundLocation = false;
                
                if (shift.code === 'XXX') {
                    log(`  Day ${dayIndex + 1}: XXX (undefined shift)`);
                    schedule.push({
                        date: weekDates[dayIndex],
                        shiftCode: 'XXX',
                        location: 'TBD',
                        hasMFS: false,
                        hasMNS: false,
                        hasFS: false
                    });
                    return;
                }
                
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    const cleaned = token.replace(/[,<]/g, '');
                    
                    if (cleaned === 'MFS') {
                        hasMFS = true;
                        continue;
                    }
                    if (cleaned === 'MNS') {
                        hasMNS = true;
                        continue;
                    }
                    if (cleaned === 'FS') {
                        hasFS = true;
                        continue;
                    }
                    
                    if (['SE', 'RCF', 'XXX', 'RT', 'L7G', 'RV', 'XXP', 'MN'].includes(cleaned)) {
                        continue;
                    }
                    
                    if (['90', '91', '92', '93', '94', '95', '96', '97', '99'].includes(cleaned)) {
                        if (foundLocation) break;
                        continue;
                    }
                    
                    if (token.match(/^OB\d$/) && i + 1 < tokens.length && tokens[i + 1].match(/^\d$/)) {
                        locationTokens.push(token + tokens[i + 1]);
                        i++;
                        foundLocation = true;
                        continue;
                    }
                    
                    if (!foundLocation) {
                        locationTokens.push(cleaned);
                        foundLocation = true;
                    }
                }
                
                if (locationTokens.length > 0) {
                    location = locationTokens.join('');
                } else {
                    location = 'SE';
                }
                
                log(`  Day ${dayIndex + 1}: ${shift.code} @ ${location}${hasMFS ? ' [MFS]' : ''}${hasMNS ? ' [MNS]' : ''}${hasFS ? ' [FS]' : ''}`);
                
                schedule.push({
                    date: weekDates[dayIndex],
                    shiftCode: shift.code,
                    location: location,
                    hasMFS: hasMFS,
                    hasMNS: hasMNS,
                    hasFS: hasFS
                });
            });
            
            log(`‚úì Total shifts extracted: ${schedule.length}`);

            return { found: true, schedule: schedule };
        }

        function getLocationName(locationCode) {
            // Since we now remove > characters during parsing, 
            // we shouldn't have them here anymore
            const trimmed = locationCode.trim();
            
            if (trimmed.startsWith('OB')) {
                return 'Outside Broadcast';
            }
            
            return LOCATIONS[trimmed] || trimmed;
        }

        function displayShifts(schedule) {
            const shiftsList = document.getElementById('shiftsList');
            shiftsList.innerHTML = '';

            const riposoNames = {
                '90': 'Festivo',
                '91': 'Non lavorato su Festivo',
                '92': 'Riposo sul Festivo',
                '93': 'CS',
                '94': 'Riposo sul semilavorato',
                '95': 'Non lavorato',
                '96': 'Riposo',
                '97': 'Part time',
                '99': 'Non lavorato su semilavorato',
                'RCF': 'Riposo su Festivo'
            };

            let workShifts = 0;
            let restDays = 0;
            let undefinedDays = 0;

            schedule.forEach((shift, idx) => {
                const times = SHIFT_TIMES[shift.shiftCode];
                const locationName = getLocationName(shift.location);
                
                const div = document.createElement('div');
                div.className = 'shift-item';
                
                if (shift.shiftCode === 'XXX') {
                    undefinedDays++;
                    div.style.opacity = '0.5';
                    div.innerHTML = `
                        <strong>${shift.date.toLocaleDateString('it-IT', { weekday: 'long', day: '2-digit', month: '2-digit' })}</strong><br>
                        <span style="color: #ffc107;">‚ö†Ô∏è Turno non definito (XXX)</span>
                    `;
                    shiftsList.appendChild(div);
                    return;
                }
                
                const isRiposo = riposoNames[shift.shiftCode];
                
                if (isRiposo) {
                    restDays++;
                    div.style.opacity = '0.6';
                }
                
                let statusHTML = '';
                if (shift.hasMFS) {
                    statusHTML += '<span class="status-badge mfs">Mancato Festivo</span>';
                }
                if (shift.hasMNS) {
                    statusHTML += '<span class="status-badge mns">Mancato</span>';
                }
                if (shift.hasFS) {
                    statusHTML += '<span class="status-badge fs">Fuori Sede</span>';
                }
                
                if (isRiposo) {
                    statusHTML += `<span class="status-badge riposo">${riposoNames[shift.shiftCode]}</span>`;
                    div.innerHTML = `
                        <strong>${shift.date.toLocaleDateString('it-IT', { weekday: 'long', day: '2-digit', month: '2-digit' })}</strong><br>
                        ${statusHTML}
                    `;
                } else {
                    workShifts++;
                    div.innerHTML = `
                        <strong>${shift.date.toLocaleDateString('it-IT', { weekday: 'long', day: '2-digit', month: '2-digit' })}</strong><br>
                        Turno: ${shift.shiftCode} (${times[0]} - ${times[1]})<br>
                        Luogo: ${locationName}
                        ${statusHTML}
                    `;
                }
                shiftsList.appendChild(div);
            });

            document.getElementById('shiftsPreview').classList.add('active');
            
            let statusMsg = `‚úì Trovati ${workShifts} turni`;
            if (restDays > 0) {
                statusMsg += `, ${restDays} giorni di riposo`;
            }
            if (undefinedDays > 0) {
                statusMsg += `, ${undefinedDays} non definiti`;
            }
            statusMsg += '!';
            showStatus(statusMsg, 'success');
        }

        function generateICS(schedule, firstName, lastName) {
            let icsContent = [
                'BEGIN:VCALENDAR',
                'VERSION:2.0',
                'PRODID:-//RAI Shift Calendar//EN',
                'CALSCALE:GREGORIAN',
                'METHOD:PUBLISH',
                'X-WR-CALNAME:RAI Turni - ' + firstName + ' ' + lastName,
                'X-WR-TIMEZONE:Europe/Rome'
            ];

            const riposoNames = {
                '90': 'Festivo', 
                '91': 'Non lavorato su Festivo',
                '92': 'Riposo sul Festivo', 
                '93': 'CS',
                '94': 'Riposo sul semilavorato', 
                '95': 'Non lavorato',
                '96': 'Riposo', 
                '97': 'Part time', 
                '99': 'Non lavorato su semilavorato',
                'RCF': 'Riposo su Festivo'
            };

            schedule.forEach(shift => {
                if (shift.shiftCode === 'XXX') {
                    return; // Skip undefined shifts
                }
                
                const times = SHIFT_TIMES[shift.shiftCode];
                if (!times) return;

                const isRiposo = riposoNames[shift.shiftCode];
                
                // Skip rest days (riposo) - only add work shifts to ICS
                if (isRiposo) {
                    console.log(`Skipping rest day from ICS: ${shift.shiftCode} on ${shift.date.toLocaleDateString('it-IT')}`);
                    return;
                }
                
                // Add work shift to calendar
                const [startHour, startMin] = times[0].split(':');
                const [endHour, endMin] = times[1].split(':');

                const startDate = new Date(shift.date);
                startDate.setHours(parseInt(startHour), parseInt(startMin), 0);

                let endDate = new Date(shift.date);
                endDate.setHours(parseInt(endHour), parseInt(endMin), 0);

                if (parseInt(endHour) < parseInt(startHour)) {
                    endDate.setDate(endDate.getDate() + 1);
                }

                const locationName = getLocationName(shift.location);
                const eventTitle = `${shift.shiftCode} - ${locationName}`;

                icsContent.push('BEGIN:VEVENT');
                icsContent.push(`DTSTART:${formatICSDate(startDate)}`);
                icsContent.push(`DTEND:${formatICSDate(endDate)}`);
                icsContent.push(`SUMMARY:${eventTitle}`);
                icsContent.push(`LOCATION:${locationName}`);
                icsContent.push(`DESCRIPTION:Turno ${shift.shiftCode}\\nOrario: ${times[0]} - ${times[1]}`);
                icsContent.push(`UID:${Date.now()}-${Math.random()}@rai-shifts`);
                icsContent.push(`DTSTAMP:${formatICSDate(new Date())}`);
                icsContent.push('END:VEVENT');
            });

            icsContent.push('END:VCALENDAR');
            return icsContent.join('\r\n');
        }

        function formatICSDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${year}${month}${day}T${hours}${minutes}${seconds}`;
        }
        
        // Function to load PDF from external source (when app is opened with a PDF)
        window.loadExternalPDF = function(base64Data, fileName) {
            console.log('=== EXTERNAL PDF LOADED ===');
            console.log('File name:', fileName);
            console.log('Base64 length:', base64Data.length);
            
            try {
                // Convert base64 to blob
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const file = new File([blob], fileName, { type: 'application/pdf' });
                
                // Create a DataTransfer to simulate file selection
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                
                const fileInput = document.getElementById('pdfFile');
                fileInput.files = dataTransfer.files;
                
                // Trigger change event
                const event = new Event('change', { bubbles: true });
                fileInput.dispatchEvent(event);
                
                console.log('‚úì External PDF loaded into file input');
                showStatus('üìÑ PDF caricato! Inserisci nome e cognome.', 'info');
            } catch (error) {
                console.error('‚úó Error loading external PDF:', error);
                showStatus('‚ùå Errore nel caricamento del PDF', 'error');
            }
        };

        document.getElementById('extractBtn').onclick = async function() {
            console.log('=== EXTRACT BUTTON CLICKED ===');
            
            const pdfFile = document.getElementById('pdfFile').files[0];
            const firstName = document.getElementById('firstName').value.trim();
            const lastName = document.getElementById('lastName').value.trim();

            log('Input validation...', {
                hasFile: !!pdfFile,
                firstName: firstName,
                lastName: lastName
            });

            if (!pdfFile) {
                console.error('‚úó No PDF file selected');
                showStatus('‚ùå Seleziona un file PDF!', 'error');
                return;
            }

            if (!firstName || !lastName) {
                console.error('‚úó Missing name fields');
                showStatus('‚ùå Inserisci nome e cognome!', 'error');
                return;
            }

            try {
                log('‚úì Starting extraction process...');
                showLoading(true);
                showStatus('', '');
                document.getElementById('shiftsPreview').classList.remove('active');

                const text = await extractTextFromPDF(pdfFile);
                log('Text extraction complete, starting schedule parsing...');
                
                const result = parseSchedule(text, firstName, lastName);
                log('Schedule parsing complete', { 
                    found: result.found, 
                    scheduleLength: result.schedule.length 
                });

                if (!result.found) {
                    console.error(`‚úó Employee "${firstName} ${lastName}" not found`);
                    showStatus(`‚ùå Dipendente "${firstName} ${lastName}" non trovato`, 'error');
                    showLoading(false);
                    return;
                }

                if (result.schedule.length === 0) {
                    console.error('‚úó No shifts found in schedule');
                    showStatus('‚ùå Nessun turno trovato', 'error');
                    showLoading(false);
                    return;
                }

                log('‚úì Extraction successful!', { shifts: result.schedule.length });
                extractedSchedule = result.schedule;
                currentFirstName = firstName;
                currentLastName = lastName;

                displayShifts(result.schedule);
                showLoading(false);
                console.log('=== EXTRACTION COMPLETE ===');

            } catch (error) {
                console.error('‚úó‚úó‚úó FATAL ERROR ‚úó‚úó‚úó');
                console.error('Error type:', error.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showStatus('‚ùå Errore: ' + error.message, 'error');
                showLoading(false);
            }
        };

        document.getElementById('downloadBtn').onclick = function() {
            console.log('=== DOWNLOAD BUTTON CLICKED ===');
            
            if (!extractedSchedule) {
                console.error('‚úó No schedule to download');
                showStatus('‚ùå Nessun turno da scaricare!', 'error');
                return;
            }

            try {
                log('Generating ICS file...', {
                    firstName: currentFirstName,
                    lastName: currentLastName,
                    shifts: extractedSchedule.length
                });
                
                const icsContent = generateICS(extractedSchedule, currentFirstName, currentLastName);
                log('‚úì ICS content generated', { length: icsContent.length });
                
                const fileName = `RAI_Turni_${currentFirstName}_${currentLastName}.ics`;
                
                // Check if running in Android WebView with download interface
                if (typeof AndroidDownload !== 'undefined' && AndroidDownload.downloadBase64) {
                    log('‚úì Android interface detected - using direct download');
                    
                    // Convert to base64 for Android
                    const base64 = btoa(unescape(encodeURIComponent(icsContent)));
                    log('‚úì Content converted to base64', { length: base64.length });
                    
                    AndroidDownload.downloadBase64(base64, fileName, 'text/calendar');
                    log('‚úì Download passed to Android');
                    
                    showStatus('‚úì File scaricato con successo!', 'success');
                    console.log('=== DOWNLOAD COMPLETE (Android) ===');
                } else {
                    // Fallback for regular browsers
                    log('‚Ñπ Using browser download (blob URL)');
                    
                    const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
                    log('‚úì Blob created', { size: blob.size, type: blob.type });
                    
                    const url = URL.createObjectURL(blob);
                    log('‚úì Object URL created', { fileName: fileName });
                    
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = fileName;
                    document.body.appendChild(link);
                    log('‚úì Download link created and added to DOM');
                    
                    link.click();
                    log('‚úì Download triggered');
                    
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    log('‚úì Cleanup complete');
                    
                    showStatus('‚úì File scaricato con successo!', 'success');
                    console.log('=== DOWNLOAD COMPLETE (Browser) ===');
                }
            } catch (error) {
                console.error('‚úó‚úó‚úó DOWNLOAD ERROR ‚úó‚úó‚úó');
                console.error('Error:', error);
                showStatus('‚ùå Errore nel download: ' + error.message, 'error');
            }
        };

        // LocalStorage with error handling for WebView
        console.log('=== INITIALIZING APP ===');
        try {
            const savedFirstName = localStorage.getItem('raiFirstName');
            const savedLastName = localStorage.getItem('raiLastName');
            
            if (savedFirstName) {
                document.getElementById('firstName').value = savedFirstName;
                log('‚úì Restored firstName from localStorage', { value: savedFirstName });
            }
            if (savedLastName) {
                document.getElementById('lastName').value = savedLastName;
                log('‚úì Restored lastName from localStorage', { value: savedLastName });
            }

            document.getElementById('firstName').addEventListener('change', function(e) {
                try {
                    localStorage.setItem('raiFirstName', e.target.value.trim());
                    log('‚úì Saved firstName to localStorage');
                } catch (err) {
                    console.warn('‚ö† LocalStorage save failed:', err);
                }
            });

            document.getElementById('lastName').addEventListener('change', function(e) {
                try {
                    localStorage.setItem('raiLastName', e.target.value.trim());
                    log('‚úì Saved lastName to localStorage');
                } catch (err) {
                    console.warn('‚ö† LocalStorage save failed:', err);
                }
            });
        } catch (err) {
            console.warn('‚ö† LocalStorage not available in WebView:', err);
        }
        
        // Android interface check
        console.log('=== CHECKING ANDROID WEBVIEW ===');
        if (typeof Android !== 'undefined') {
            console.log('‚úì Running in Android WebView - Android interface detected');
            console.log('Android object:', Android);
        } else {
            console.log('‚ö† Android interface NOT found');
        }
        
        // Check for AndroidDownload interface
        if (typeof AndroidDownload !== 'undefined') {
            console.log('‚úì AndroidDownload interface detected');
            console.log('AndroidDownload object:', AndroidDownload);
            console.log('Has downloadBase64 method:', typeof AndroidDownload.downloadBase64 === 'function');
        } else {
            console.log('‚ö† AndroidDownload interface NOT found - will use browser download');
        }
        
        // Check for WebView user agent
        const isWebView = navigator.userAgent.includes('wv');
        console.log('WebView detected in user agent:', isWebView);
        
        // Check if file input is accessible
        const fileInput = document.getElementById('pdfFile');
        console.log('File input element:', fileInput);
        console.log('File input type:', fileInput.type);
        console.log('File input accept:', fileInput.accept);
        
        // File input click listener
        document.getElementById('pdfFile').addEventListener('click', function(e) {
            console.log('üñ±Ô∏è File input CLICKED');
            console.log('Click event:', e);
        });
        
        // File input focus listener
        document.getElementById('pdfFile').addEventListener('focus', function(e) {
            console.log('üéØ File input FOCUSED');
        });
        
        // File input change listener
        document.getElementById('pdfFile').addEventListener('change', function(e) {
            console.log('üìù File input CHANGE event fired');
            if (e.target.files.length > 0) {
                const file = e.target.files[0];
                log('üìé File selected', {
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    lastModified: new Date(file.lastModified).toISOString()
                });
            } else {
                log('‚ö† File selection cleared or cancelled');
            }
        });
        
        console.log('‚úì All event listeners attached');
        console.log('=== APP READY ===');
    </script>
</body>
</html>
